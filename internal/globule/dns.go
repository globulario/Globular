package globule

import (
	"context"
	"errors"
	"fmt"
	"net"
	"net/http"
	"os"
	"path/filepath"
	"strings"
	"time"

	"github.com/globulario/Globular/internal/legacy/bootstrap"
	"github.com/globulario/Globular/internal/logsink"
	"github.com/globulario/services/golang/config"
	"github.com/globulario/services/golang/dns/dns_client"
	"github.com/globulario/services/golang/log/logpb"
	"github.com/globulario/services/golang/security"
	Utility "github.com/globulario/utility"
	"github.com/txn2/txeh"
)

// maybeStartDNSAndRegister starts dns.DnsService if configured locally, then registers A/AAAA/MX, etclient.
func (g *Globule) maybeStartDNSAndRegister(ctx context.Context) error {
	const svcName = "dns.DnsService"

	desc, bin, err := g.describeServiceByName(svcName, 5*time.Second)
	if err != nil {
		g.log.Warn("dns describe failed (service binary not found yet?)", "err", err)
		// best-effort: still attempt register using external DNS if possible
		return g.registerIPToDNS()
	}

	if g.SkipLocalDNS {
		g.log.Info("dns start skipped (gateway mode)")
		return g.registerIPToDNS()
	}

	alloc, err := config.NewDefaultPortAllocator()
	if err != nil {
		return err
	}

	desired, err := g.mergeOrCreateDesired(desc, alloc)
	if err != nil {
		return fmt.Errorf("dns desired creation failed: %w", err)
	}

	desired["Path"] = bin
	desired["Domain"] = g.Domain
	desired["Address"] = g.localIPAddress
	desired["Mac"] = g.Mac

	if err := config.SaveServiceConfiguration(desired); err != nil {
		return fmt.Errorf("dns desired save failed: %w", err)
	}

	id := Utility.ToString(desired["Id"])
	if id == "" {
		return fmt.Errorf("dns desired missing Id")
	}
	state := ""
	if cfg, _ := config.GetServiceConfigurationById(id); cfg != nil {
		state = Utility.ToString(cfg["State"])
	}
	if state == "running" {
		return g.registerIPToDNS()
	}

	address, _ := config.GetAddress()
	port := Utility.ToInt(desired["Port"])
	proxy := Utility.ToInt(desired["Proxy"])
	address = strings.Split(address, ":")[0]
	addr := net.JoinHostPort(address, fmt.Sprint(port))
	name := svcName

	outW := logsink.NewServiceLogWriter(address, name, "sa", "/"+name+"/stdout", logpb.LogLevel_INFO_MESSAGE, os.Stdout)
	errW := logsink.NewServiceLogWriter(address, name, "sa", "/"+name+"/stderr", logpb.LogLevel_ERROR_MESSAGE, os.Stderr)

	g.log.Info("starting dns", "port", port, "proxy", proxy, "path", desired["Path"])
	pid, err := bootstrap.StartDNSService(ctx, desired, port, outW, errW)
	if err != nil {
		_ = config.PutRuntime(id, map[string]any{"Process": -1, "State": "failed", "LastError": err.Error()})
		g.log.Warn("dns start failed", "err", err)
		return g.registerIPToDNS()
	}
	_ = config.PutRuntime(id, map[string]any{"Process": pid, "State": "starting", "LastError": ""})
	desired["Process"] = pid

	if !g.UseEnvoy {
		if _, err := bootstrap.StartDNSProxy(ctx, desired, config.GetLocalCertificateAuthorityBundle(), config.GetLocalCertificate()); err != nil {
			g.log.Warn("dns proxy start failed", "err", err)
		}
	}

	ok := g.waitServiceReady(name, addr, 15*time.Second)
	if !ok {
		_ = config.PutRuntime(id, map[string]any{"State": "failed", "LastError": "dns startup timeout"})
		g.log.Warn("dns failed to become ready")
		return g.registerIPToDNS()
	}
	_ = config.PutRuntime(id, map[string]any{"State": "running", "LastError": ""})

	return g.registerIPToDNS()
}

// setHost unchanged ...

// registerIPToDNS fixes: guaranteed non-empty primary NS for SOA; minor tidies.
func (g *Globule) registerIPToDNS() error {
	if g.DNS == "" {
		return nil
	}

	domain := g.Domain
	localFQDN := g.Name + "." + g.Domain

	const resolvHdr = "# Generated by Globular at startup. Original saved as resolv.conf_\n"
	resolvConf := resolvHdr + "nameserver 8.8.8.8\nnameserver 1.1.1.1\n"
	if Utility.Exists("/etc/resolv.conf") {
		_ = Utility.MoveFile("/etc/resolv.conf", "/etc/resolv.conf_")
		_ = Utility.WriteStringToFile("/etc/resolv.conf", resolvConf)
	}

	endpoints := g.dnsBootstrapEndpoints()
	if len(endpoints) == 0 {
		endpoints = []string{g.DNS}
	}

	tried := make([]string, 0, len(endpoints))
	var (
		client  *dns_client.Dns_Client
		used    string
		lastErr error
	)

	for _, endpoint := range endpoints {
		cli, err := dns_client.NewDnsService_Client(endpoint, "dns.DnsService")
		if err == nil {
			client = cli
			used = endpoint
			break
		}
		lastErr = err
		tried = append(tried, fmt.Sprintf("%s (%v)", endpoint, err))
	}

	if client == nil {
		if lastErr == nil {
			lastErr = errors.New("dns client connection failed")
		}
		detail := strings.Join(tried, "; ")
		if detail == "" {
			detail = "no endpoints attempted"
		}
		return fmt.Errorf("dns client failed: %w; tried endpoints: %s", lastErr, detail)
	}

	defer client.Close()
	g.DNS = used
	if g.DNS == "" {
		g.DNS = endpoints[len(endpoints)-1]
	}

	if g.DNS == localFQDN {
		const maxTry = 20
		for try := 0; try < maxTry; try++ {
			cfg, err := config.GetServiceConfigurationById(client.GetId())
			if err == nil && cfg["State"] == "running" {
				break
			}
			time.Sleep(time.Second)
			if try == maxTry-1 {
				return fmt.Errorf("dns server not running")
			}
		}
	}

	tk, err := security.GenerateToken(g.SessionTimeout, client.GetMac(), "sa", "", g.AdminEmail, g.Domain)
	if err != nil {
		return fmt.Errorf("token: %w", err)
	}

	ipv4 := Utility.MyIP()
	if ipv4 == "" {
		return errors.New("no public IPv4")
	}
	ipv6, _ := Utility.MyIPv6()

	// first of all, set domains on the authority
	domains := []string{}
	for _, v := range g.AlternateDomains {
		alt := strings.TrimPrefix(fmt.Sprint(v), "*.")
		domains = append(domains, alt)
	}
	if !Utility.Contains(domains, domain) {
		domains = append(domains, domain)
	}
	if err := client.SetDomains(tk, domains); err != nil {
		return fmt.Errorf("set domains: %w", err)
	}

	// Primary host (A/AAAA)
	_ = client.RemoveA(tk, localFQDN)
	if _, err := client.SetA(tk, localFQDN, ipv4, 60); err != nil {
		return fmt.Errorf("set A %s: %w", localFQDN, err)
	}
	if ipv6 != "" {
		if _, err := client.SetAAAA(tk, localFQDN, ipv6, 60); err != nil {
			return fmt.Errorf("set AAAA %s: %w", localFQDN, err)
		}
	}

	// Alternates (A/AAAA), NS, SOA, CAA
	for _, v := range g.AlternateDomains {
		alt := strings.TrimPrefix(fmt.Sprint(v), "*.")
		if _, err := client.SetA(tk, alt, ipv4, 60); err != nil {
			return fmt.Errorf("set A %s: %w", alt, err)
		}
		if ipv6 != "" {
			if _, err := client.SetAAAA(tk, alt, ipv6, 60); err != nil {
				return fmt.Errorf("set AAAA %s: %w", alt, err)
			}
		}

		// publish glue for each NS host
		for _, rawNS := range g.NS {
			ns := fmt.Sprint(rawNS)
			if _, err := client.SetA(tk, ns, ipv4, 60); err != nil {
				return fmt.Errorf("set A NS %s: %w", ns, err)
			}
			if ipv6 != "" {
				if _, err := client.SetAAAA(tk, ns, ipv6, 60); err != nil {
					return fmt.Errorf("set AAAA NS %s: %w", ns, err)
				}
			}
		}

		// Delegate NS at apex
		altDot := alt
		if !strings.HasSuffix(altDot, ".") {
			altDot += "."
		}
		for _, rawNS := range g.NS {
			ns := fmt.Sprint(rawNS)
			if !strings.HasSuffix(ns, ".") {
				ns += "."
			}
			if err := client.SetNs(tk, altDot, ns, 60); err != nil {
				return fmt.Errorf("set NS %s -> %s: %w", altDot, ns, err)
			}
		}

		// SOA â€” ensure primaryNS not empty
		primaryNS := ""
		if len(g.NS) > 0 {
			primaryNS = fmt.Sprint(g.NS[0])
			if !strings.HasSuffix(primaryNS, ".") {
				primaryNS += "."
			}
		} else {
			primaryNS = "ns1." + domain + "."
		}
		if primaryNS == "" {
			primaryNS = "ns1." + domain + "."
		}

		email := g.AdminEmail
		if email == "" || !strings.Contains(email, "@") {
			email = "admin@" + domain
		}
		if !strings.HasSuffix(email, ".") {
			email += "."
		}
		const (
			serial  = uint32(1)
			refresh = uint32(86400)
			retry   = uint32(7200)
			expire  = uint32(4000000)
			ttl     = uint32(11200)
		)
		if err := client.SetSoa(tk, altDot, primaryNS, email, serial, refresh, retry, expire, ttl, ttl); err != nil {
			return fmt.Errorf("set SOA %s: %w", altDot, err)
		}

		if err := client.SetCaa(tk, alt+".", 0, "issue", "letsencrypt.org", 60); err != nil {
			return fmt.Errorf("set CAA %s: %w", alt, err)
		}
	}

	// Mail, SPF, DMARC, MTA-STS
	mailHost := "mail." + domain
	if _, err := client.SetA(tk, mailHost, ipv4, 60); err != nil {
		return fmt.Errorf("set A %s: %w", mailHost, err)
	}
	if ipv6 != "" {
		if _, err := client.SetAAAA(tk, mailHost, ipv6, 60); err != nil {
			return fmt.Errorf("set AAAA %s: %w", mailHost, err)
		}
	}
	if err := client.SetMx(tk, domain, 10, mailHost, 60); err != nil {
		return fmt.Errorf("set MX %s: %w", domain, err)
	}

	_ = client.RemoveText(tk, domain+".")
	spf := fmt.Sprintf(`v=spf1 mx ip4:%s include:_spf.google.com ~all`, ipv4)
	if err := client.SetText(tk, domain+".", []string{spf}, 60); err != nil {
		return fmt.Errorf("set SPF TXT: %w", err)
	}

	_ = client.RemoveText(tk, "_dmarclient."+domain+".")
	dmarc := fmt.Sprintf(`v=DMARC1;p=quarantine;rua=mailto:%s;ruf=mailto:%s;adkim=r;aspf=r;pct=100`, g.AdminEmail, g.AdminEmail)
	if err := client.SetText(tk, "_dmarclient."+domain+".", []string{dmarc}, 60); err != nil {
		return fmt.Errorf("set DMARC TXT: %w", err)
	}

	mtaPath := filepath.Join(g.configDir, "tls", localFQDN, "mta-sts.txt")
	if !Utility.Exists(mtaPath) {
		policy := fmt.Sprintf("version: STSv1\nmode: enforce\nmx: %s\nttl: 86400\n", domain)
		_ = os.WriteFile(mtaPath, []byte(policy), 0600)
	}
	if _, err := client.SetA(tk, "mta-sts."+domain, ipv4, 60); err != nil {
		return fmt.Errorf("set A mta-sts: %w", err)
	}
	_ = client.RemoveText(tk, "_mta-sts."+domain+".")
	if err := client.SetText(tk, "_mta-sts."+domain+".", []string{"v=STSv1; id=globular;"}, 60); err != nil {
		return fmt.Errorf("set _mta-sts TXT: %w", err)
	}

	for _, raw := range g.DNSUpdateIPInfos {
		m := raw.(map[string]interface{})
		setA, key, secret := m["SetA"].(string), m["Key"].(string), m["Secret"].(string)
		body := `[{"data":"` + ipv4 + `"}]`
		req, _ := http.NewRequest(http.MethodPut, setA, strings.NewReader(body))
		req.Header.Set("Content-Type", "application/json; charset=utf-8")
		req.Header.Set("Authorization", "sso-key "+key+":"+secret)
		_, _ = (&http.Client{Timeout: 10 * time.Second}).Do(req)
	}

	return g.setHost(config.GetLocalIP(), localFQDN)
}

const defaultDNSPort = "10033"

func (g *Globule) dnsBootstrapEndpoints() []string {
	if g.DNS == "" {
		return nil
	}
	port := dnsPortOrDefault(g.DNS)
	seen := map[string]struct{}{}
	list := make([]string, 0, 4)
	add := func(addr string) {
		addr = strings.TrimSpace(addr)
		if addr == "" {
			return
		}
		if _, ok := seen[addr]; ok {
			return
		}
		seen[addr] = struct{}{}
		list = append(list, addr)
	}

	if port != "" {
		add(net.JoinHostPort("127.0.0.1", port))
		if g.localIPAddress != "" {
			add(net.JoinHostPort(g.localIPAddress, port))
		}
	}

	hostWithPort := g.DNS
	if _, _, err := net.SplitHostPort(g.DNS); err != nil {
		if port != "" {
			hostWithPort = net.JoinHostPort(g.DNS, port)
		}
	}
	if hostWithPort != "" {
		add(hostWithPort)
	}
	add(g.DNS)

	return list
}

func dnsPortOrDefault(addr string) string {
	if _, port, err := net.SplitHostPort(addr); err == nil && port != "" {
		return port
	}
	return defaultDNSPort
}

// setHost maps an IPv4 to a hostname in the system hosts file.
// - If the current mapping is local (127.* / 10.* / 192.168.* / etclient.), we refuse to overwrite it with a non-local IP.
// - Handles "localhost" specially (forces 127.0.0.1).
func (g *Globule) setHost(ipv4, address string) error {
	if strings.HasSuffix(address, ".localhost") {
		return nil
	}
	if address == "localhost" {
		ipv4 = "127.0.0.1"
	}
	if ipv4 == "" {
		return errors.New("setHost: empty ipv4")
	}
	if address == "" {
		return errors.New("setHost: empty address")
	}

	h, err := txeh.NewHostsDefault()
	if err != nil {
		return err
	}

	exists, prev, _ := h.HostAddressLookup(address, txeh.IPFamilyV4)
	if exists && Utility.IsLocal(prev) && !Utility.IsLocal(ipv4) {
		// Keep existing local mapping; admin can override manually if desired.
		return nil
	}

	h.AddHost(ipv4, address)
	return h.Save()
}
