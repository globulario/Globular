package globule

import (
	"context"
	"errors"
	"fmt"
	"net"
	"net/http"
	"os"
	"path/filepath"
	"strings"
	"time"

	"github.com/globulario/services/golang/config"
	"github.com/globulario/services/golang/dns/dns_client"
	"github.com/globulario/services/golang/security"
	Utility "github.com/globulario/utility"
	"github.com/txn2/txeh"
)

// maybeStartDNSAndRegister ensures dns.DnsService desired config exists locally, then registers A/AAAA/MX, etc.
func (g *Globule) maybeStartDNSAndRegister(ctx context.Context) error {
	const svcName = "dns.DnsService"

	if g.SkipLocalDNS {
		g.log.Info("dns desired config check skipped (gateway mode)")
		return g.registerIPToDNS(ctx)
	}

	if err := g.bootstrapServiceConfigsFromDisk(); err != nil {
		g.log.Warn("dns bootstrap: seed configs failed (continuing)", "err", err)
	}

	g.NotifyNodeAgentReconcile(ctx)

	cfg, err := config.GetServiceConfigurationById(svcName)
	if err != nil {
		g.log.Warn("dns desired config lookup failed", "err", err)
		return g.registerIPToDNS(ctx)
	}
	if cfg == nil {
		g.log.Warn("dns desired config missing; ensure service config JSON is present", "service", svcName)
		return g.registerIPToDNS(ctx)
	}

	g.log.Info("dns desired config exists; using configured values", "service", svcName)
	if err := g.registerIPToDNS(ctx); err != nil {
		if g.DNS == g.Name+"."+g.Domain {
			return fmt.Errorf("dns service not ready yet: %w", err)
		}
		return err
	}
	return nil
}

// setHost unchanged ...

// registerIPToDNS fixes: guaranteed non-empty primary NS for SOA; minor tidies.
func (g *Globule) registerIPToDNS(ctx context.Context) error {
	if g.DNS == "" {
		return nil
	}

	domain := g.Domain
	localFQDN := g.Name + "." + g.Domain

	if g.MutateResolvConf {
		const (
			resolvConfPath   = "/etc/resolv.conf"
			resolvConfBackup = "/etc/resolv.conf_"
		)
		if info, err := os.Lstat(resolvConfPath); err == nil && info.Mode().IsRegular() {
			if _, err := os.Stat(resolvConfBackup); err == nil {
				g.log.Warn("resolv.conf mutation skipped; backup file already exists", "backup", resolvConfBackup)
			} else if os.IsNotExist(err) {
				const resolvHdr = "# Generated by Globular at startup. Original saved as resolv.conf_\n"
				resolvConf := resolvHdr + "nameserver 8.8.8.8\nnameserver 1.1.1.1\n"
				if err := Utility.MoveFile(resolvConfPath, resolvConfBackup); err != nil {
					g.log.Warn("failed to backup resolv.conf", "err", err)
				}
				if err := Utility.WriteStringToFile(resolvConfPath, resolvConf); err != nil {
					g.log.Warn("failed to write resolv.conf", "err", err)
				} else {
					g.log.Warn("resolv.conf replaced with public nameservers", "target", resolvConfPath)
				}
			} else {
				g.log.Warn("resolv.conf mutation skipped", "err", err)
			}
		} else if err != nil {
			g.log.Warn("resolv.conf mutation skipped", "err", err)
		} else {
			g.log.Warn("resolv.conf mutation skipped; not a regular file", "path", resolvConfPath)
		}
	}

	endpoints := g.dnsBootstrapEndpoints()
	if len(endpoints) == 0 {
		endpoints = []string{g.DNS}
	}

	tried := make([]string, 0, len(endpoints))
	var (
		client  *dns_client.Dns_Client
		used    string
		lastErr error
	)

	for _, endpoint := range endpoints {
		cli, err := dns_client.NewDnsService_Client(endpoint, "dns.DnsService")
		if err == nil {
			client = cli
			used = endpoint
			break
		}
		lastErr = err
		tried = append(tried, fmt.Sprintf("%s (%v)", endpoint, err))
	}

	if client == nil {
		if lastErr == nil {
			lastErr = errors.New("dns client connection failed")
		}
		detail := strings.Join(tried, "; ")
		if detail == "" {
			detail = "no endpoints attempted"
		}
		return fmt.Errorf("dns client failed: %w; tried endpoints: %s", lastErr, detail)
	}

	defer client.Close()
	g.DNS = used
	if g.DNS == "" {
		g.DNS = endpoints[len(endpoints)-1]
	}

	if g.DNS == localFQDN && !g.SkipLocalDNS {
		const maxTry = 20
		for try := 0; try < maxTry; try++ {
			cfg, err := config.GetServiceConfigurationById(client.GetId())
			if err == nil && cfg["State"] == "running" {
				break
			}
			time.Sleep(time.Second)
			if try == maxTry-1 {
				return fmt.Errorf("dns server not running")
			}
		}
	}

	tk, err := security.GenerateToken(g.SessionTimeout, client.GetMac(), "sa", "", g.AdminEmail, g.Domain)
	if err != nil {
		return fmt.Errorf("token: %w", err)
	}

	ipv4 := Utility.MyIP()
	if ipv4 == "" {
		return errors.New("no public IPv4")
	}
	ipv6, _ := Utility.MyIPv6()

	// first of all, set domains on the authority
	domains := []string{}
	for _, v := range g.AlternateDomains {
		alt := strings.TrimPrefix(fmt.Sprint(v), "*.")
		domains = append(domains, alt)
	}
	if !Utility.Contains(domains, domain) {
		domains = append(domains, domain)
	}
	if err := client.SetDomains(tk, domains); err != nil {
		return fmt.Errorf("set domains: %w", err)
	}

	// Primary host (A/AAAA)
	_ = client.RemoveA(tk, localFQDN)
	if _, err := client.SetA(tk, localFQDN, ipv4, 60); err != nil {
		return fmt.Errorf("set A %s: %w", localFQDN, err)
	}
	if ipv6 != "" {
		if _, err := client.SetAAAA(tk, localFQDN, ipv6, 60); err != nil {
			return fmt.Errorf("set AAAA %s: %w", localFQDN, err)
		}
	}

	// Alternates (A/AAAA), NS, SOA, CAA
	for _, v := range g.AlternateDomains {
		alt := strings.TrimPrefix(fmt.Sprint(v), "*.")
		if _, err := client.SetA(tk, alt, ipv4, 60); err != nil {
			return fmt.Errorf("set A %s: %w", alt, err)
		}
		if ipv6 != "" {
			if _, err := client.SetAAAA(tk, alt, ipv6, 60); err != nil {
				return fmt.Errorf("set AAAA %s: %w", alt, err)
			}
		}

		// publish glue for each NS host
		for _, rawNS := range g.NS {
			ns := fmt.Sprint(rawNS)
			if _, err := client.SetA(tk, ns, ipv4, 60); err != nil {
				return fmt.Errorf("set A NS %s: %w", ns, err)
			}
			if ipv6 != "" {
				if _, err := client.SetAAAA(tk, ns, ipv6, 60); err != nil {
					return fmt.Errorf("set AAAA NS %s: %w", ns, err)
				}
			}
		}

		// Delegate NS at apex
		altDot := alt
		if !strings.HasSuffix(altDot, ".") {
			altDot += "."
		}
		for _, rawNS := range g.NS {
			ns := fmt.Sprint(rawNS)
			if !strings.HasSuffix(ns, ".") {
				ns += "."
			}
			if err := client.SetNs(tk, altDot, ns, 60); err != nil {
				return fmt.Errorf("set NS %s -> %s: %w", altDot, ns, err)
			}
		}

		// SOA â€” ensure primaryNS not empty
		primaryNS := ""
		if len(g.NS) > 0 {
			primaryNS = fmt.Sprint(g.NS[0])
			if !strings.HasSuffix(primaryNS, ".") {
				primaryNS += "."
			}
		} else {
			primaryNS = "ns1." + domain + "."
		}
		if primaryNS == "" {
			primaryNS = "ns1." + domain + "."
		}

		email := g.AdminEmail
		if email == "" || !strings.Contains(email, "@") {
			email = "admin@" + domain
		}
		if !strings.HasSuffix(email, ".") {
			email += "."
		}
		const (
			serial  = uint32(1)
			refresh = uint32(86400)
			retry   = uint32(7200)
			expire  = uint32(4000000)
			ttl     = uint32(11200)
		)
		if err := client.SetSoa(tk, altDot, primaryNS, email, serial, refresh, retry, expire, ttl, ttl); err != nil {
			return fmt.Errorf("set SOA %s: %w", altDot, err)
		}

		if err := client.SetCaa(tk, alt+".", 0, "issue", "letsencrypt.org", 60); err != nil {
			return fmt.Errorf("set CAA %s: %w", alt, err)
		}
	}

	// Mail, SPF, DMARC, MTA-STS
	mailHost := "mail." + domain
	if _, err := client.SetA(tk, mailHost, ipv4, 60); err != nil {
		return fmt.Errorf("set A %s: %w", mailHost, err)
	}
	if ipv6 != "" {
		if _, err := client.SetAAAA(tk, mailHost, ipv6, 60); err != nil {
			return fmt.Errorf("set AAAA %s: %w", mailHost, err)
		}
	}
	if err := client.SetMx(tk, domain, 10, mailHost, 60); err != nil {
		return fmt.Errorf("set MX %s: %w", domain, err)
	}

	_ = client.RemoveText(tk, domain+".")
	spf := fmt.Sprintf(`v=spf1 mx ip4:%s include:_spf.google.com ~all`, ipv4)
	if err := client.SetText(tk, domain+".", []string{spf}, 60); err != nil {
		return fmt.Errorf("set SPF TXT: %w", err)
	}

	_ = client.RemoveText(tk, "_dmarc."+domain+".")
	dmarc := fmt.Sprintf(`v=DMARC1;p=quarantine;rua=mailto:%s;ruf=mailto:%s;adkim=r;aspf=r;pct=100`, g.AdminEmail, g.AdminEmail)
	if err := client.SetText(tk, "_dmarc."+domain+".", []string{dmarc}, 60); err != nil {
		return fmt.Errorf("set DMARC TXT: %w", err)
	}

	mtaPath := filepath.Join(g.configDir, "tls", localFQDN, "mta-sts.txt")
	if !Utility.Exists(mtaPath) {
		policy := fmt.Sprintf("version: STSv1\nmode: enforce\nmx: %s\nttl: 86400\n", domain)
		_ = os.WriteFile(mtaPath, []byte(policy), 0600)
	}
	if _, err := client.SetA(tk, "mta-sts."+domain, ipv4, 60); err != nil {
		return fmt.Errorf("set A mta-sts: %w", err)
	}
	_ = client.RemoveText(tk, "_mta-sts."+domain+".")
	if err := client.SetText(tk, "_mta-sts."+domain+".", []string{"v=STSv1; id=globular;"}, 60); err != nil {
		return fmt.Errorf("set _mta-sts TXT: %w", err)
	}

	for _, raw := range g.DNSUpdateIPInfos {
		m := raw.(map[string]interface{})
		setA, key, secret := m["SetA"].(string), m["Key"].(string), m["Secret"].(string)
		body := `[{"data":"` + ipv4 + `"}]`
		req, _ := http.NewRequest(http.MethodPut, setA, strings.NewReader(body))
		req.Header.Set("Content-Type", "application/json; charset=utf-8")
		req.Header.Set("Authorization", "sso-key "+key+":"+secret)
		_, _ = (&http.Client{Timeout: 10 * time.Second}).Do(req)
	}

	if g.MutateHostsFile {
		if err := g.setHost(config.GetLocalIP(), localFQDN); err != nil {
			g.log.Warn("setHost failed", "err", err)
		}
	}
	return nil
}

const defaultDNSPort = "10033"

func (g *Globule) dnsBootstrapEndpoints() []string {
	if g.DNS == "" {
		return nil
	}
	port := dnsPortOrDefault(g.DNS)
	seen := map[string]struct{}{}
	list := make([]string, 0, 4)
	add := func(addr string) {
		addr = strings.TrimSpace(addr)
		if addr == "" {
			return
		}
		if _, ok := seen[addr]; ok {
			return
		}
		seen[addr] = struct{}{}
		list = append(list, addr)
	}

	if port != "" {
		add(net.JoinHostPort("127.0.0.1", port))
		if g.localIPAddress != "" {
			add(net.JoinHostPort(g.localIPAddress, port))
		}
	}

	hostWithPort := g.DNS
	if _, _, err := net.SplitHostPort(g.DNS); err != nil {
		if port != "" {
			hostWithPort = net.JoinHostPort(g.DNS, port)
		}
	}
	if hostWithPort != "" {
		add(hostWithPort)
	}
	add(g.DNS)

	return list
}

func dnsPortOrDefault(addr string) string {
	if _, port, err := net.SplitHostPort(addr); err == nil && port != "" {
		return port
	}
	return defaultDNSPort
}

// setHost maps an IPv4 to a hostname in the system hosts file.
// - If the current mapping is local (127.* / 10.* / 192.168.* / etclient.), we refuse to overwrite it with a non-local IP.
// - Handles "localhost" specially (forces 127.0.0.1).
func (g *Globule) setHost(ipv4, address string) error {
	if strings.HasSuffix(address, ".localhost") {
		return nil
	}
	if address == "localhost" {
		ipv4 = "127.0.0.1"
	}
	if ipv4 == "" {
		return errors.New("setHost: empty ipv4")
	}
	if address == "" {
		return errors.New("setHost: empty address")
	}

	h, err := txeh.NewHostsDefault()
	if err != nil {
		return err
	}

	exists, prev, _ := h.HostAddressLookup(address, txeh.IPFamilyV4)
	if exists && Utility.IsLocal(prev) && !Utility.IsLocal(ipv4) {
		// Keep existing local mapping; admin can override manually if desired.
		return nil
	}

	h.AddHost(ipv4, address)
	return h.Save()
}
