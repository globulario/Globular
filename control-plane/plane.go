// Package controlplane provides functionality to manage an xDS control plane server,
// including starting the server, managing configuration snapshots, and handling
// Envoy xDS resources such as clusters, routes, and listeners.
//
// The package leverages Envoy's go-control-plane library to implement xDS server
// operations and resource management.
//
// Types:
//   - EndPoint: Represents a gRPC server endpoint with host, port, and priority.
//   - Snapshot: Encapsulates the configuration snapshot for clusters, routes, listeners,
//     and TLS certificates.
//
// Functions:
//   - StartControlPlane: Starts an xDS server on the specified port, serving the provided
//     snapshot, and blocks until termination or context cancellation.
//   - AddSnapshot: Adds a configuration snapshot to the cache for a given node ID and version.
//   - RemoveSnapshot: Removes a snapshot from the cache for a specified node ID.
//   - GetSnapshot: Retrieves the current snapshot for a given node ID.
//
// Concurrency:
//   - Internal resource management is protected by a mutex to ensure thread safety
//     when accessing or modifying the snapshot cache.
package controlplane

import (
	"context"
	"fmt"
	"sync"

	"github.com/envoyproxy/go-control-plane/pkg/cache/types"
	cache_v3 "github.com/envoyproxy/go-control-plane/pkg/cache/v3"
	resource_v3 "github.com/envoyproxy/go-control-plane/pkg/resource/v3"
	server_v3 "github.com/envoyproxy/go-control-plane/pkg/server/v3"
	test_v3 "github.com/envoyproxy/go-control-plane/pkg/test/v3"
)

var (
	l     Logger
	mu    sync.Mutex
	cache = cache_v3.NewSnapshotCache(false, cache_v3.IDHash{}, l)
)

// StartControlPlane starts the control plane xDS server in a separate goroutine.
// It listens on the specified port and runs until either the provided context is canceled
// or a signal is received on the exit channel. The function waits for the server goroutine
// to finish before returning. Returns an error if any occurs during startup.
//
// Parameters:
//
//	ctx  - Context for cancellation and timeout control.
//	port - Port number to listen on.
//	exit - Channel to signal server termination.
//
// Returns:
//
//	error - Any error encountered during server startup or execution.
func StartControlPlane(ctx context.Context, port uint, exit chan bool) error {

	var wg sync.WaitGroup
	wg.Add(1)

	// Run the xDS server in a goroutine
	go func() {
		defer wg.Done()
		cb := &test_v3.Callbacks{Debug: l.Debug}
		srv := server_v3.NewServer(ctx, cache, cb)
		fmt.Println("Starting the xDS server...")
		RunServer(srv, port)
		fmt.Println("xDS server terminated")
	}()

	// Wait for either the server to finish or the context to be canceled
	select {
	case <-ctx.Done():
		// Context canceled, wait for the goroutine to finish
		wg.Wait()
	case <-exit: // Assuming you have a channel to signal server termination
		// Server terminated, nothing to do here
	}

	return nil
}

// EndPoint represents a gRPC server that serves Envoy xDS requests
type EndPoint struct {
	Host     string
	Port     uint32
	Priority uint32
}

// Snapshot represents the configuration snapshot.
type Snapshot struct {

	// The cluster name and the route name
	ClusterName string

	// The route to limit the scope of the cluster
	// ex: /resource.ResourceService
	RouteName string

	// The listener name, host, and port
	ListenerName string
	ListenerHost string
	ListenerPort uint32

	// The list of gRPC servers that make part of the cluster
	// The cluster name is used to identify the cluster in the route
	EndPoints []EndPoint

	// TLS configuration, certificates must be valid for the given endpoints

	// Certificates used by gRPC
	ServerCertPath string // The server certificate file path (crt format).
	KeyFilePath    string // The server key file path (PEM format).
	CAFilePath     string

	// Certificates used by https
	IssuerFilePath string // The path to the issuer (Let's Encrypt) certificate
	CertFilePath   string // The certificate generated by the issuer (Let's Encrypt)
}

// AddSnapshot creates and adds a new snapshot to the cache for the given id and version.
// It constructs clusters, routes, and listeners from the provided Snapshot values,
// organizes them by resource type, and stores them in a snapshot.
// Returns an error if snapshot creation or cache update fails.
//
// Parameters:
//   - id:      Identifier for the snapshot.
//   - version: Version string for the snapshot.
//   - values:  Slice of Snapshot structs containing resource configuration.
//
// Returns:
//   - error: Non-nil if snapshot creation or cache update fails.
func AddSnapshot(id, version string, values []Snapshot) error {
	mu.Lock()
	defer mu.Unlock()

	// Create a map to store resources by type
	resources := make(map[string][]types.Resource)

	// Iterate over the provided values and create clusters, routes, and listeners
	for _, value := range values {

		cluster := MakeCluster(value.ClusterName, value.ServerCertPath, value.KeyFilePath, value.CAFilePath, value.EndPoints)

		route := MakeRoute(value.RouteName, value.ClusterName, value.ListenerHost)

		listener := MakeHTTPListener(value.ListenerHost, value.ListenerPort, value.ListenerName, value.RouteName, value.CertFilePath, value.KeyFilePath, value.IssuerFilePath)

		// Add the resources to the map
		resources[resource_v3.ClusterType] = append(resources[resource_v3.ClusterType], cluster)
		resources[resource_v3.RouteType] = append(resources[resource_v3.RouteType], route)
		resources[resource_v3.ListenerType] = append(resources[resource_v3.ListenerType], listener)
	}

	// Create a new snapshot and set it in the cache
	snapshot, err := cache_v3.NewSnapshot(version, resources)
	if err != nil {
		return err
	}

	l.Debugf("will serve snapshot %+v", snapshot)

	// Set the snapshot in the cache
	return cache.SetSnapshot(context.Background(), id, snapshot)
}

// RemoveSnapshot removes the cached snapshot associated with the given nodeID.
// It acquires a lock to ensure thread safety during the removal process.
func RemoveSnapshot(nodeID string) {
	mu.Lock()
	defer mu.Unlock()
	cache.ClearSnapshot(nodeID)
}

// GetSnapshot retrieves the ResourceSnapshot for the specified nodeID from the cache.
// It acquires a lock to ensure thread-safe access to the cache.
// Returns the ResourceSnapshot and an error if retrieval fails.
func GetSnapshot(nodeID string) (cache_v3.ResourceSnapshot, error) {
	mu.Lock()
	defer mu.Unlock()
	return cache.GetSnapshot(nodeID)
}
