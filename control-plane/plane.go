package controlplane

import (
	"context"
	"encoding/json"
	"fmt"
	"sync"

	"github.com/envoyproxy/go-control-plane/pkg/cache/types"
	"github.com/envoyproxy/go-control-plane/pkg/cache/v3"
	"github.com/envoyproxy/go-control-plane/pkg/resource/v3"
	"github.com/envoyproxy/go-control-plane/pkg/server/v3"
	"github.com/envoyproxy/go-control-plane/pkg/test/v3"
)

var (
	l      Logger
	mu     sync.Mutex
	cache_ = cache.NewSnapshotCache(false, cache.IDHash{}, l)
)

/**
 * StartControlPlane starts an xDS server at the given port, serving the given
 * snapshot. It blocks until the server terminates or until the context is canceled.
 */
func StartControlPlane(ctx context.Context, port uint, exit chan bool) error {

	// I will test a simple snapshot with a single cluster, route, and listener
	/*snapshot := GenerateSnapshot()
	if err := snapshot.Consistent(); err != nil {
		l.Errorf("snapshot inconsistency: %+v\n%+v", snapshot, err)
		return err
	}

	l.Debugf("will serve snapshot %+v", snapshot)

	jsonSnapshot, err := json.MarshalIndent(snapshot, "", "  ")
	if err != nil {
		l.Errorf("snapshot error %q for %+v", err, snapshot)
		return err	
	}
	fmt.Println("------> json snapshot: ", string(jsonSnapshot))


	// Add the snapshot to the cache
	if err := cache_.SetSnapshot(context.Background(), "test-id", snapshot); err != nil {
		l.Errorf("snapshot error %q for %+v", err, snapshot)
		return err
	}*/


	var wg sync.WaitGroup
	wg.Add(1)

	// Run the xDS server in a goroutine
	go func() {
		defer wg.Done()
		cb := &test.Callbacks{Debug: l.Debug}
		srv := server.NewServer(ctx, cache_, cb)
		fmt.Println("Starting the xDS server...")
		RunServer(srv, port)
		fmt.Println("xDS server terminated")
	}()

	// Wait for either the server to finish or the context to be canceled
	select {
	case <-ctx.Done():
		// Context canceled, wait for the goroutine to finish
		wg.Wait()
	case <-exit: // Assuming you have a channel to signal server termination
		// Server terminated, nothing to do here
	}

	return nil
}

// gRPC server that serves Envoy xDS requests
type EndPoint struct {
	Host string
	Port uint32
}

// Snapshot represents the configuration snapshot.
type Snapshot struct {

	// The cluster name and the route name
	ClusterName    string

	// The route to limit the scope of the cluster
	// ex: /resource.ResourceService
	RouteName      string

	// The listener name, host, and port
	ListenerName   string
	ListenerHost   string
	ListenerPort   uint32

	// The list of gRPC servers that make part of the cluster
	// The cluster name is used to identify the cluster in the route
	EndPoints []EndPoint

	// TLS configuration, certificates must be valid for the given endpoints

	// Certificates used by gRPC
	ServerCertPath    string // The server certificate file path (crt format).
	KeyFilePath  string // The server key file path (PEM format).
	CAFilePath   string

	// Certificates used by https
	IssuerFilePath string // The path to the issuer (Let's Encrypt) certificate
	CertFilePath string  // The certificate generated by the issuer (Let's Encrypt)
}

func AddSnapshot(id, version string, values []Snapshot) error{
	mu.Lock()
	defer mu.Unlock()

	// Create a map to store resources by type
	resources := make(map[resource.Type][]types.Resource)

	// Iterate over the provided values and create clusters, routes, and listeners
	for _, value := range values {

		cluster := MakeCluster(value.ClusterName, value.ServerCertPath, value.KeyFilePath, value.CAFilePath, value.EndPoints)
		
		route := MakeRoute(value.RouteName, value.ClusterName, value.ListenerHost)

		listener := MakeHTTPListener(value.ListenerHost, value.ListenerPort, value.ListenerName, value.ClusterName, value.RouteName, value.CertFilePath, value.KeyFilePath, value.IssuerFilePath)

		// Add the resources to the map
		resources[resource.ClusterType] = append(resources[resource.ClusterType], cluster)
		resources[resource.RouteType] = append(resources[resource.RouteType], route)
		resources[resource.ListenerType] = append(resources[resource.ListenerType], listener)
	}

	// Create a new snapshot and set it in the cache
	snapshot, err := cache.NewSnapshot(version, resources)
	if err != nil {
		return err
	}


	l.Debugf("will serve snapshot %+v", snapshot)
	jsonSnapshot, err := json.MarshalIndent(snapshot, "", "  ")
	if err != nil {
		l.Errorf("snapshot error %q for %+v", err, snapshot)
		return err	
	}
	fmt.Println("------> json snapshot: ", string(jsonSnapshot))


	// Set the snapshot in the cache
	return cache_.SetSnapshot(context.Background(), id, snapshot)
}


// RemoveSnapshot removes a snapshot from the cache.
func RemoveSnapshot(nodeID string) {
	mu.Lock()
	defer mu.Unlock()
	cache_.ClearSnapshot(nodeID)
}

// GetSnapshot returns the current snapshot for a given node ID.
func GetSnapshot(nodeID string) (cache.Snapshot, error){
	mu.Lock()
	defer mu.Unlock()
	return cache_.GetSnapshot(nodeID)
}